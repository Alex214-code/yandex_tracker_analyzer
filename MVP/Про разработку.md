**Про архитектуру**
В качестве основной архитектуры (исключение - небольшие простые приложения) при разработке серверных приложений на python выбрана архитектура "портов и адаптеров" (альтернативное название "гексагональная архитектура"). Использование такой архитектуры позволяет изолировать приложение от деталей реализации, таких как временные (постоянно изменяющиеся) технологии, инструменты и механизмы доставки, что упрощает и ускоряет тестирование и создание пригодного для повторного использования прототипа.
Подробнее с данной архитектурой можно ознакомиться по ссылкам: 
https://herbertograca.com/2017/09/14/ports-adapters-architecture/
https://alistair.cockburn.us/hexagonal-architecture
https://habr.com/ru/companies/timeweb/articles/771338/

**Про стек и выбор библиотек**
Базовый стек: python 3.11, uvicorn, fastapi, sqlalchemy, loguru, httpx, pydantic, poetry.
При принятии решения о добавлении в проект новых библиотек, выбирать следует только те библиотеки, которые свободно распространяются (open source), имеют хороший рейтинг и качественную документацию, разрабатываются командой (несколько contributers), а также активно выпускаются новые версии, что говорит о том, что поддержка осуществляется. **Обязательно** следует проверить на выявленные сообществом уязвимости. Также, следует согласовать библиотеку со старшим разработчиком на проекте или архитектором (иногда возможны исключения из правил, но с обоснованием).

**Про общие правила оформления кода**
При написании кода всегда стоит учитывать тот факт, что его будут изучать и дорабатывать другие люди, поэтому необходимо уделить внимание его **декомпозиции**, покрытию docstrings (google style) и подбору наиболее **выразительных** названий (process_data() - плохо, calculate_sum_of_doubled_even_numbers() - хорошо). Допускается использование транслитерации в названиях, которые отражают специфичные термины предметной области и не поддаются однозначному переводу. Следует применять правила SOLID, DRY, YAGNI и KISS. Обязательно применение type hinting (подсказок типов). Обязательно использование ruff (линтер и форматтер), а также mypy (статический анализатор типов). Данные инструменты настраиваются индивидуально под требования конкретного проекта и его команды (в целом не запрещается использовать настройки по умолчанию, потом настройки можно по мере необходимости корректировать, но обосновывая и согласовывая внутри команды). Обязательно использование pre-commit, это позволит при фиксации изменений с помощью git, автоматически выполнять проверки ruff и mypy, чтобы исключить попадание некачественного кода в общий репозиторий. **Запрещено** использовать вызов print() в основных ветках репозитория. **Запрещено** прописывать в коде значения секретов (их значения могут быть только в .env файле, который должен быть указан в .gitignore).

**Про структуру проекта**
Пример структуры (предварительно нужно ознакомиться с принципами архитектуры "портов и адаптеров", иначе будет сложно понять почему она такая):
```
- docs/ # Файлы с документацией (заметки, схемы, диаграммы)
- scripts/ # Различные вспомогательные скрипты (например, sh-скрипт для запуска)
- tests/ # Автоматические тесты (модульные, интеграционные)
- ...
- src/
	- adapers/
		- primary/ # Первичные (управляющие) адаптеры
			- web/ # Отвечают за обработку запросов к приложению по web-протоколам (http, websocket, sse)
			- opc/  # Отвечают за обработку запросов к приложению по opc-протоколам (opcua, opcda)
			- cli/ # Отвечают за обработку запросов к приложению с помощью cli-интерфейса
		- secondary/ # Вторичные (управляемые) адаптеры
			- persistence/ # Отвечают за долговременное хранение состояния приложения (извлечение и сохранение данных приложения)
			- notifications/ # Отвечают за отправку уведомлений из приложения внешним потребителям
			- authentification/ # Отвечают за взаимодействие с внешним SSO-сервисом для выполнения аутентификации и авторизации
	- core/
		- application/ # Приложение
			- ports/ # Интерфейсы, которые приложение выставляет для адаптеров, и которые адаптеры должны реализовать (порты тоже разделяются на primary и secondary, но допускается определять только secondary порты (пока не видим в primary портах профита))
			- use_cases/ # Сервисы приложения, которые отвечают за выполнение определенных сценариев в ответ на запросы от пользователей или других систем. В ходе сценария выполняют оркестрацию адаптерами и доменными сервисами. 
			- ...
		- domain/ # Домен
			- models/ # Доменные модели (классы, описывающие сущности, могут быть обычными DTO при анимичной доменной модели)
			- services/ # Доменные сервисы, которые реализуют бизнес-правила (доменные правила, правила предметной области) (например, сервис расчета скидки), сервисы могут определять свои DTO.
			- ...
		- ...
	- entrypoints/
		- run.py # main.py (может быть несколько файлов запуска, например для запуска web-сервера (run_web_server.py), opc-сервера (run_opc_server.py) или cli-интерфейса run_cli_interface.py).
	- container.py # Отвечает за сборку зависимостей (имеется ввиду DIC)
	- settings.py # Тут все настройки приложения (либо значение по умолчанию, либо значение устанавливается из переменной окружения, можно использовать pydantic для реализации)
- Dockerfile
- pyproject.toml
- poetry.lock
- .gitignore
- .dockerignore
- .pre-commit-config.yaml
- alembic.ini
- ruff.toml
- README.md
- ... # Другие конфигурационные файлы не относящиеся к исходному коду.

```

Данные между слоями передаются в виде DTO. 
Когда код образует самодостаточный пакет/модуль, то внутренний импорт должен быть относительным, в остальных случаях, когда требуется импорт из другого пакета/модуля, использовать абсолютный импорт.

**Про тестирование**
Код должен быть покрыт модульными и интеграционными автоматическими тестами.
Модульные тесты проверяют отдельный компонент (модуль или класс), даже если он зависит от других классов в рамках этого же модуля, изолируя его от внешних зависимостей (модулей и внешних систем, таких как базы данных, файловые хранилища...) с помощью заглушек. Интеграционные тесты проверяют компонент (модуль или класс) во взаимодействии с другими модулями или внешними системами, при этом не часть зависимостей  все же может быть заглушена. Тест конечной точки API предлагается классифицировать как интеграционный. e2e тесты не автоматизируются, а выполняются вручную. В качестве тестовой оснастки необходимо использовать pytest. На данный момент нет стандартов как писать код тестов, поэтому можно предлагать на рассмотрение различные варианты, пока что это решается на уровне команды проекта. Обязательно требуется производить тестирование на выявление утечек памяти (если приложение должно компилироваться, то необходимо проверять утечки до компиляции и после). 

**Про структурные миграции базы данных**
Если приложение управляет долговременным хранением своего состояния (извлекает и хранит данные в базе/-ах данных, хранилищах, на диске),  то считается, что оно владеет этими данными и может управлять структурой их хранения. Поэтому применяются инструменты выполнения структурных миграций. Для реляционных баз данных применяется alembiс (он хорошо интегрирован с sqlalchemy). Для других типов хранилищ пока с такими задачами не сталкивались, но возможно, и там есть подобные инструменты. Структурные миграции, да и не только структурные, это очень опасные операции над хранилищем данных, поэтому перед их применением нужно все тщательно проверять, особенно когда используется автоматическая генерация файлов миграций на основе таблиц sqlalchemy (там могут быть ошибки и неточности).  

**Про производительность приложений**
Для повышения производительности приложений применяется асинхронность, особенно это актуально, когда есть существенные задержки на I/O bound операциях. Если есть долгая CPU bound операция (сложное математическое вычисление на большом объеме данных) и это критично для приложения (другие запросы/задачи не должны блокироваться на это время), то такую операцию следует выносить в отдельный процесс (можно и в поток, но только если этот код не написан на чистом python, а например использует библиотеку, основанную на C-расширениях (например, numpy, scipy...), иначе толку не будет из-за GIL). При наличии asyncio задачу можно выполнить в отдельном процессе при помощи asyncio.run_in_executor(). Но в любом случае, требуется делать измерение эффективности принимаемых мер по повышению производительности, не стоит усложнять код, если нет должного эффекта от решения. Также веб-сервисы, запущенные под uvicorn, могут быть запущены в несколько параллельных процессов (воркеров), под управлением uvicorn, который будет выступать как маршрутизатор/балансировщик запросов до воркеров и менеджер воркеров. 

**Про мягкое завершение приложений**
Очень важно чтобы при завершении работы приложения, она корректно завершила свои задачи и освободила ресурсы. Завершение приложения может произойти, например, при остановке её docker-контейнера, при этом docker посылает сигнал о предстоящем завершении основному процессу (в случае использования uvicorn, то родительскому процессу uvicorn), далее родительский процесс передает данный сигнал каждому воркеру. Воркеры должны его корректно обработать и завершиться до того, как docker принудительно завершит процесс. В приложениях с fastapi, код завершения может быть помещен в lifespan и fastapi сам управляет обработкой сигнала завершения. Но если приложение разрабатывается без фреймворков, обеспечивающих обработку сигнала завершения, это нужно делать самостоятельно, это ОЧЕНЬ ВАЖНО. 

**Про транзакции**
При работе с транзакциями важно обеспечить целостность данных. Для операций, которые затрагивают несколько таблиц, используется одна транзакция — либо все изменения сохраняются, либо откатываются. Для **распределенных** транзакций применяются подходы, такие как повторные попытки и двухфазная фиксация. В случаях, когда целостность данных критична, можно рассмотреть возможность использования шаблонов, таких как saga, которые позволяют управлять долгосрочными транзакциями в распределенных системах.

**Про ведение журналов**
Логи следует писать в стандартный вывод и в структурированном формате. Так в дальнейшем будет проще снять их с контейнера и агрегировать, например, в loki. В логах обязательно должен присутствовать идентификатор процесса (PID) по которому можно определить какой воркер написал лог (в случае с запуском uvicorn с несколькими воркерами). Для записи логов в приложении следует использовать loguru. Обработчики и форматтеры настраиваются так, как это необходимо на проекте. Если в логи попадают ошибки, то следует записать их вместе с трассировкой. Если необходимо (по какой-причине писать логи в файл, то при использовании uvicorn с воркерами, нужно сделать так, чтобы у каждого воркера был свой файл, иначе будут проблемы с доступом к разделяемому ресурсу, эта ситуация описана в официальной доке loguru).

**Про работу с git и публикацию изменений на сервер**
Приложения запускаются в docker-контейнерах. У нас внедрена автоматизация процесса доставки и развертывания приложений, которая реализована на базе CI/CD Gitlab. За нее отвечают DEVOPS-инженеры. Они же подготавливают репозиторий. Поэтому в README.md должна быть вся необходимая информация, чтобы они понимали как упаковывать приложение в docker-образ, запускать линтеры и автоматические тесты и запускать потом на сервере. У них должна быть полная информация о переменных окружения (настройки приложения), которые необходимо устанавливать в среде выполнения приложения, это ОЧЕНЬ ВАЖНО, поэтому в README.md должна быть таблица с колонками: название переменной, описание, значение по умолчанию, варианты значений (с описанием каждого варианта). Как основной рабочий процесс применяется gitflow. О правилах внесения вклада в проект есть отдельная заметка.

**Про наши внутренние python-пакеты**
Код, который должен переиспользоваться в разных проектах (репозиториях) выносим в python-пакет (распространяемый пакет). Для таких пакетов есть свои репозитории, у которых настроен свой CICD пайплайн, по итогу сборки в реестре пакетов Gitlab появляются новые версии пакетов, которые в дальнейшем можно установить/обновить в своем проекте с помощью poetry. Таким образом упрощается процесс централизованной доставки изменений в разные репозитории, ну и уменьшается дублирование и нарушение целостности. 






